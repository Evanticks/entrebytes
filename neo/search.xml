<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Configurar kernel a medida</title>
      <link href="/2022/11/16/Compilar-debian-a-medida/"/>
      <url>/2022/11/16/Compilar-debian-a-medida/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/linux-6.0.jpg" alt="Descripción de la imagen"></p><p>Comenzaremos creando una carpeta que nos sirva de entorno de trabajo</p><p><code>mkdir kernel &amp;&amp; cd kernel</code></p><p>Instalamos las dependencias que nos ayudarán a compilar el kernel, el cual nos ahorrará errores en la compilación:</p><p><code>sudo apt install build-essential flex nbison openssl libssl-dev dkms libncurses-dev ncurses-dev qtbase5-dev libelf-dev</code></p><p>Nos vamos ahora a kernel.org a descargarnos la última versión del kernel de linux.</p><p>Una vez descargado el kernel lo descomprimimos con el comando tar -xvf linux-6.0.7.tar.gz, ingresamos dentro y vemos que entre muchos archivos, encontramos un makefile, entramos dentro y encontraremos el archivo EXTRAVERSION, el cual pondremos una versión para poder llevar un control de versiones.</p><p>Entramos dentro del directorio descomprimido y procedemos a generar el <code>make oldconfig</code> que creará el archivo .config con los módulos que deberemos compilar, intentamos contestar a las preguntas de forma negativa para que no genere módulos opcionales.</p><p>Una vez hecho esto debemos de adaptar los módulos que está utilizando nuestra máquina para compilar el kernel a medida, entonces utilizaremos un <code>make localyesconfig</code></p><pre><code>╭─antonio@debian ~/Programas/kernel/linux-6.0.7  ╰─➤  egrep &#39;=y&#39; .config | wc -l                                                                                                 130 ↵1934╭─antonio@debian ~/Programas/kernel/linux-6.0.7  ╰─➤  egrep &#39;=m&#39; .config | wc -l3</code></pre><p>Una vez hecho esto procederemos a probar nuestro kernel a medida <code>make -j8 bindeb-pkg</code> pudiendo así compilar el kernel, le otorgaremos 8 jobs y si agregamos un time <code>time make -j8 bindeb-pkg</code> podemos ver la duración que ha tardado el sistema en compilarlo.</p><p>Reiniciamos nuestra máquina y entramos en el nuevo kernel, utilizamos <code>uname -r</code></p><p>Luego volvemos a nuestro kernel, y en concreto a nuestro espacio de trabajo, ejecutamos un <code>make clean</code> para eliminar los ‘residuos’ generados tras al compilación, y hacemos un control de versiones del .config, como nos funcionó la primera versión realizamos un <code>cp .config ../v1.config</code></p><p><img src="/images/xconfig.png" alt="Descripción de la imagen"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Interconexiones entre Bases de Datos</title>
      <link href="/2022/11/09/Interconexiones/"/>
      <url>/2022/11/09/Interconexiones/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/oracle-19c-logo.png" alt="remoto"></p><h2 id="Interconexion-entre-dos-bases-de-datos-Oracle"><a href="#Interconexion-entre-dos-bases-de-datos-Oracle" class="headerlink" title="Interconexión entre dos bases de datos Oracle."></a>Interconexión entre dos bases de datos Oracle.</h2><p>Antes que nada debemos saber que para conectarnos a una base de datos, debemos tener activados los listener y seguidamente tener en el tsnames.ora la base de datos a la que queremos conectarnos, de esta manera:<br>sudo nano &#x2F;opt&#x2F;oracle&#x2F;product&#x2F;19c&#x2F;dbhome_1&#x2F;network&#x2F;admin&#x2F;tnsnames.ora</p><pre><code>ORCLCDB =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.122.20)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = ORCLCDB)    )  )LISTENER_ORCLCDB =  (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.122.20)(PORT = 1521))ORACLESERV =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.122.168)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = ORCLCDB)    )  )</code></pre><p>Hemos creado una nueva conexión llamada ORACLESERV en el cual procederemos a ingresar la ip del servidor del que queremos recibir los datos, tras esto debemos crear en la otra máquina la tabla de ejemplo que queremos extraer:</p><pre><code>CREATE TABLE armas (codarma varchar2 (3),nombre varchar2 (20),fuerza number (2),destreza number (2),inteligencia number (2),rareza varchar2 (10),nivel number (2),CONSTRAINT pk_armas PRIMARY KEY (codarma));insert into armas values (&#39;001&#39;,&#39;Espada Corta&#39;,8,10,0,&#39;D&#39;,5);insert into armas values (&#39;002&#39;,&#39;Espada Larga&#39;,10,10,0,&#39;C&#39;,8);insert into armas values (&#39;003&#39;,&#39;Espada Artorias&#39;,24,18,20,&#39;S&#39;,30);insert into armas values (&#39;004&#39;,&#39;Hacha de Mano&#39;,8,8,0,&#39;D&#39;,6);insert into armas values (&#39;005&#39;,&#39;Hacha de Gárgola&#39;,14,14,0,&#39;A&#39;,15);insert into armas values (&#39;006&#39;,&#39;Hacha de Demonio&#39;,46,0,0,&#39;S&#39;,40);</code></pre><p>Una vez hecho esto, <strong>nos vamos a la máquina en la que vamos a trabajar con la consulta</strong>, debemos crear un enlace a la base de datos, el cual hemos predefinido como ORACLESERV:</p><p><code>create database link ORACLESERVIDOR connect to antonio identified by antonio using &#39;ORACLESERV&#39;;</code></p><p>Tras esto, viene una parte un poco compleja, ya que la tabla que vamos a consultar en el otro servidor viene relacionada, y a la hora de crear relaciones entre tablas no se puede especificar una base de datos remota en el DDL, entonces, cómo podemos hacer que esto funcione? bueno pues mi idea ha sido crear una vista materializada:</p><p><code>create materialized view mv_armas as select codarma from armas@ORACLESERVIDOR;</code></p><p>Una vez hecho esto, procedemos a crear las tablas personaje y equipar, siendo una relación N,M.</p><pre><code>CREATE TABLE personaje (codpersonaje varchar2 (3),nombre varchar2 (15),altura number (3,2),peso number (3),raza varchar2 (10),CONSTRAINT pk_codpersonaje PRIMARY KEY (codpersonaje),CONSTRAINT ck_codpersonaje CHECK (REGEXP_LIKE(codpersonaje,&#39;^1.*$&#39;)));insert into personaje values (&#39;101&#39;,&#39;Solaire&#39;,1.70,80,&#39;humano&#39;);insert into personaje values (&#39;102&#39;,&#39;Artorias&#39;,1.90,90,&#39;hueco&#39;);insert into personaje values (&#39;103&#39;,&#39;Gargola&#39;,3.10,680,&#39;Gárgola&#39;);CREATE TABLE equipar (codpersonaje varchar2 (3),codarma varchar2 (3),fecha date,CONSTRAINT pk_equipar PRIMARY KEY (codpersonaje,codarma,fecha),CONSTRAINT fk_codpersonaje FOREIGN KEY (codpersonaje) REFERENCES personaje (codpersonaje),CONSTRAINT fk_codarma FOREIGN KEY (codarma) REFERENCES mv_armas(codarma););insert into equipar values (&#39;102&#39;,&#39;003&#39;,to_date(&#39;2011/02/11&#39;,&#39;YYYY/MM/DD&#39;));insert into equipar values (&#39;103&#39;,&#39;005&#39;,to_date(&#39;2011/05/04&#39;,&#39;YYYY/MM/DD&#39;));insert into equipar values (&#39;101&#39;,&#39;002&#39;,to_date(&#39;2011/06/03&#39;,&#39;YYYY/MM/DD&#39;));insert into equipar values (&#39;103&#39;,&#39;002&#39;,to_date(&#39;2011/09/02&#39;,&#39;YYYY/MM/DD&#39;));insert into equipar values (&#39;101&#39;,&#39;006&#39;,to_date(&#39;2011/08/03&#39;,&#39;YYYY/MM/DD&#39;));insert into equipar values (&#39;102&#39;,&#39;004&#39;,to_date(&#39;2011/07/01&#39;,&#39;YYYY/MM/DD&#39;));</code></pre><p>¡¡Mucho ojo!! la restricción que he establecido en equipar, que es la foreign key que relaciona el código de armas con nuestra base de datos, llamará a la view que hemos creado y contendrá los datos de la consulta al servidor externo.</p><p><img src="/images/sql-remoto.png" alt="remoto"></p><p><img src="/images/sql-remoto2.png" alt="remoto"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ansible + Vagrant, configurar y enrutar servidor web.</title>
      <link href="/2022/10/13/Ansible+Vagrant/"/>
      <url>/2022/10/13/Ansible+Vagrant/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ansibleandvagrant.jpg" alt="Descripción de la imagen"></p><p>Comenzaremos este post viendo como adjuntamos una box <a href="https://app.vagrantup.com/boxes/search">https://app.vagrantup.com/boxes/search</a><br>buscamos por ejemplo la de debian&#x2F;ullseye, vamos a nuestra terminal y escribimos lo siguiente:<br><code>vagrant box add debian/bullseye64</code></p><p>En ese momento se guardará en <code>~/.vagrant.d/boxes</code><br>Bueno, dicho esto procedemos a crear la carpeta donde vamos a trabajar y hacemos un <code>vagrant init</code>, esto hará que se cree un archivo llamado vagrantfile, el cual debe quedar de la siguiente manera:</p><pre><code>Vagrant.configure(&quot;2&quot;) do |config|    config.vm.define :nodo1 do |nodo1|      nodo1.vm.box = &quot;debian/bullseye64&quot;      nodo1.vm.hostname= &quot;nodo1&quot;      nodo1.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;, disabled: true      nodo1.vm.network :public_network,        :dev =&gt; &quot;br0&quot;,        :mode =&gt; &quot;bridge&quot;,        :type =&gt; &quot;bridge&quot;,        use_dhcp_assigned_default_route: true      nodo1.vm.network :private_network,        :libvirt__network_name =&gt; &quot;red1&quot;,        :libvirt__dhcp_enabled =&gt; false,        :ip =&gt; &quot;10.0.0.10&quot;,        :libvirt__forward_mode =&gt; &quot;veryisolated&quot;    end    config.vm.define :nodo2 do |nodo2|      nodo2.vm.box = &quot;debian/bullseye64&quot;      nodo2.vm.hostname = &quot;nodo2&quot;      nodo2.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;, disabled: true      nodo2.vm.network :private_network,        :libvirt__network_name =&gt; &quot;red1&quot;,        :libvirt__dhcp_enabled =&gt; false,        :ip =&gt; &quot;10.0.0.11&quot;,        :libvirt__forward_mode =&gt; &quot;veryisolated&quot;,        use_dhcp_assigned_default_route: true    endend</code></pre><p>Vamos a explicar paso por paso qué vemos en el código:</p><ul><li>El vagrantfile debe estar perfectamente alineado, los end con sus respectivos config.</li><li>Al ser dos máquinas las vamos a llamar nodo1 y nodo2, que una será el router y la segunda el servidor que aloje apache</li><li>Si nos fijamos con atención podemos ver que <strong>nodo1</strong> tiene dos redes, una será pública, la cual tiene un bridge por donde saldrá a internet, y una red privada muy aislada, la cual no contendrá nada más que una ip estática, pondremos que la ruta por defecto va a ser el bridge que nos llevará a internet.</li><li>En <strong>nodo2</strong> tendremos una red privada, más tarde procederemos a ejecutar unas reglas que nos permitan salir por el exterior a través de la red muy aislada con <strong>nat</strong></li></ul><p>Una vez hecho esto procedemos a ver de cerca lo que contiene Ansible, el cual ejecutaremos tras iniciar las máquinas de Vagrant junto con sus redes.</p><p><img src="/images/Ansible.png" alt="Descripción de la imagen"></p><p>Como podemos ver, hay una serie de carpetas llamadas roles, cada rol va a ejecutar una o varias tareas dependiendo de lo que se trate, por lo tanto así quedaría por ejemplo el activado del bit de forwarding del router:</p><pre><code>- ansible.posix.sysctl:    name: net.ipv4.ip_forward    value: &#39;1&#39;    sysctl_set: yes</code></pre><p>Estas tareas tienen un orden, y se realiza dentro de site.yml:</p><pre><code>- hosts: nodo1  become: true  roles:   - role: copy- hosts: all  become: true  roles:   - role: commons- hosts: nodo2  become: true  roles:   - role: copy2   - role: apache2- hosts: nodo1  become: true  roles:   - role: ipv4</code></pre><p>Con un poco de conocimientos en sistemas podemos ver claramente qué realiza cada rol.</p><p>Ahora vamos a poner la lupa en <code>roles/commons/handlers/main.yaml</code>, una parte muy importante de la ejecución de Ansible:</p><pre><code>- name: reiniciando maquina  ansible.builtin.reboot:    msg: &quot;reboot by Ansible&quot;    pre_reboot_delay: 5    post_reboot_delay: 10    test_command: &quot;whoami&quot;</code></pre><p>Este handler se ejecuta en el momento en el que se hace un llamamiento, en nuestro caso es cuando copiamos al router un fichero configurado para etc&#x2F;network&#x2F;interfaces, con sus interfaces, ruta por defecto e iptables:</p><p><img src="/images/interfaces.png" alt="Descripción de la imagen"></p><p>podemos ver como en <code>roles/copy/tasks/main.yaml</code> hace el llamamiento al <strong>handler</strong> en el notify:</p><pre><code>- name: Copiando al etc/network/interfaces  ansible.builtin.copy:    src: interfaz_nodo1/interfaces    dest: /etc/network/    owner: root    group: root    mode: u-rw,g-wx,o-rwx  notify:    - reiniciando maquina</code></pre><p>A continuación podemos copiar nuestra clave pública a través de la tarea <strong>commons</strong> que será lo que nos permita atravesar por ssh sin utilizar la clave vagrant, es decir, la nuestra.</p><pre><code>- name: Ensure system is updated  apt: update_cache=yes upgrade=yes- name: Set authorized key took from file  authorized_key:    user: vagrant    state: present    key: &quot;&#123;&#123; lookup('file', '/home/antonio/.ssh/id_rsa.pub') &#125;&#125;&quot;</code></pre><p>Luego pasamos a la instalación de Apache,a través del módulo apt para instalar apache2, ports.conf es la configuración de los puertos por los que escucha, también alberga el fichero index.html y una plantilla jinja2.</p><p>Por último pero no menos importante está el fichero hosts, el cual será el inventario por el cual el sistema sabrá cuál será nodo1 y cuál nodo2, a través de las correspondientes ips que asignaremos,el usuario más la clave privada que asignará vagrant:</p><pre><code>all:  children:    servidores_web:      hosts:        nodo1:          ansible_ssh_host: 192.168.121.212          ansible_ssh_user: vagrant          ansible_ssh_private_key_file: ../.vagrant/machines/nodo1/libvirt/private_key        nodo2:          ansible_ssh_host: 192.168.121.111          ansible_ssh_user: vagrant          ansible_ssh_private_key_file: ../.vagrant/machines/nodo2/libvirt/private_key</code></pre><p>con esto solo necesitaremos ejecutar el <code>ansible-playbook site.yaml</code> y tendremos enrutado y configurado nuestro servidor web.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Instalación preseed PXE+APACHE</title>
      <link href="/2022/10/04/Preseed-pxe/"/>
      <url>/2022/10/04/Preseed-pxe/</url>
      
        <content type="html"><![CDATA[<p>Vamos a crear la máquina virtual como hicimos anteriormente en <a href="https://entrebytes.neocities.org/2022/09/30/preseed/">Instalación automatizada basada en medio de almacenamiento extraíble.</a></p><p>En vagrant creamos una máquina que tenga una ip estática 192.168.100.3 que va a ser la tarjeta de red por la que funcionará pxe, en mi caso no creó esa ip y la tuve que escribir a mano en el &#x2F;etc&#x2F;network&#x2F;interfaces, la otra tarjeta de red es la de vagrant-libvirt que será la que nos conecte al exterior.</p><p>Para proceder a configurar el protocolo <strong>TFTP</strong> Y <strong>DHCP</strong> para que sea el host el que conceda ip a la máquina y establezca la conexión al preseed, utilizando dnsmasq</p><p>apt install dnsmasq</p><p>Establecemos en el fichero &#x2F;etc&#x2F;dnsmaq.conf con los siguientes parámetros:</p><p><code>dhcp-range=192.168.100.100,192.168.100.200,255.255.255.0</code></p><p>Establecemos el fichero con  el que va a bootear el dhcp:</p><p><code>dhcp-boot=pxelinux.0</code></p><p>Habilitamos el tftp:<br><code>enable-tftp</code></p><p>Establecemos una ruta donde va a albergar nuestro Debian:<br><code>tftp-root=/srv/tftp</code></p><p>Creamos la carpeta en &#x2F;srv<br><code>sudo mkdir /srv/tftp</code></p><p>a continuación instalamos el wget y lo usamos en &#x2F;srv&#x2F;tftp</p><p><code>wget http://ftp.debian.org/debian/dists/bullseye/main/installer-amd64/current/images/netboot/netboot.tar.gz </code></p><p><code>tar -zxf netboot.tar.gz</code> (para descomprimir los archivos)<br><code>rm netboot.tar.gz</code></p><p><code>srv/tftp/debian-installer/amd64/boot-screens/txt.cfg</code></p><p>En este fichero de configuración utilizamos los siguientes parámetros:</p><pre><code>label install        menu label ^Install        kernel debian-installer/amd64/linux        append vga=788 initrd=debian-installer/amd64/initrd.gz --- quietlabel unattended-gnome        menu label ^Instalacion Debian Desatendida Preseed        kernel debian-installer/amd64/linux        append vga=788 initrd=debian-installer/amd64/initrd.gz hostname=preseed domain=preseed preseed/url=192.168.100.5/preseed.cfg locale=en_US.UTF-8 console-setup/charmap=UTF-8 console-setup/ask_detect=false keyboard-configuration/xkb-keymap=us --</code></pre><p>En este label he puesto la url del servidor apache que vamos a utilizar, para que descargue el preseed y lo inyecte en la instalación.</p><p>Instalamos apache2:<br><code>sudo apt install apache2</code></p><p>luego copiamos el preseed, lo ponemos en <code>/var/www/html/</code> junto al index.html, hacemos la página HTML que albergue el preseed y la ruta ya está establecida en el txt.cfg</p><p>Una vez hecho esto, para que nuestra máquina que se conecta a la tarjeta de red estática que hemos creado, necesitamos establecer unas reglas de nftables que nos ayudará a conseguir que la máquina que conecte con el servidor pxe salga al exterior para descargar las dependencias.</p><p>Para ello, debemos activar el bit de forwarding que se halla en <code>/etc/sysctl.conf</code> y descomentamos <code>#net.ipv4.ip_forward=1</code></p><p>Instalamos y habilitamos nftables(Todo esto siendo root):</p><p><code>apt install nftables</code><br><code>systemctl start nftables.service</code><br><code>systemctl enable nftables.service</code><br><code>nft add table nat</code><br><code>nft list tables</code></p><p>ahora realizamos las reglas de nftables para conseguir que esas máquinas tengan internet:<br><code>nft add chain nat postrouting &#123; type nat hook postrouting priority 100 \; &#125;</code><br><code>nft add rule ip nat postrouting oifname &quot;eth0&quot; ip saddr 192.168.100.0/24 counter masquerade</code></p><p>Ahora guardamos los cambios: <code>nft list ruleset &gt; /etc/nftables.conf</code></p><p>Ahora en virt-manager procedemos a crear y enlazar una máquina a una red aislada:</p><pre><code>&lt;network connections=&quot;2&quot;&gt;  &lt;name&gt;red_muy_aislada&lt;/name&gt;  &lt;uuid&gt;b0083374-5cb6-4a8d-bd3c-32cf0d870b54&lt;/uuid&gt;  &lt;bridge name=&quot;virbr3&quot; stp=&quot;on&quot; delay=&quot;0&quot;/&gt;  &lt;mac address=&quot;52:54:00:e9:be:50&quot;/&gt;&lt;/network&gt;</code></pre><p> debemos arrancarla por red como prioridad, luego de esto funcionará perfectamente nuestra instalación desatendida.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Instalación automatizada basada en medio de almacenamiento extraíble.</title>
      <link href="/2022/09/30/preseed/"/>
      <url>/2022/09/30/preseed/</url>
      
        <content type="html"><![CDATA[<p>He comenzado descargando el archivo iso para poder abrirlo y colocar el preseed en él, el comando que he utilizado es xorriso.<br>Tras esto he utilizado una plantilla de la web de debian</p><p><a href="https://www.debian.org/releases/buster/example-preseed.txt">https://www.debian.org/releases/buster/example-preseed.txt</a></p><p>Tras esto he estado configurando preseed.cfg para poner la hora, el país y el teclado en español y resulta que estuve un tiempo estancado en esto porque hay que corroborar los cambios en el archivo isofiles&#x2F;isolinux&#x2F;txt.cfg<br>A su vez también debemos indicar la ruta donde vama a estar el preseed para que el sistema lo localice, en mi caso estará en la raíz de la ISO (CDROM)</p><pre><code>label install        menu label ^Install        kernel /install.amd/vmlinuz        append vga=788 initrd=/install.amd/initrd.gz --- quietlabel unattended-gnome menu label ^Instalación Debian Desatendida Preseed Antonio kernel /install.amd/gtk/vmlinuz append vga=788 initrd=/install.amd/gtk/initrd.gz preseed/file=/cdrom/preseed.cfg locale=es_ES console-setup/ask_detect=false keyboard-configuration/xkb-keymap=es</code></pre><p>Al tener que desensamblar y ensamblar constantemente el iso para poner el preseed actualizado llegó un momento en el que se hacía inviable seguir probando sin hacer un script con los pasos que se repetían, entonces lo realicé:</p><pre><code>#!/usr/bin/env bashfichero=/home/antonio/Descargas/preseed-instalacion/preseed-debian-10.1.0-amd64-script-netinst.isochmod u+w isofilescp preseed.cfg ~/Descargas/preseed-instalacion/isofileschmod u-w isofilescd ~/Descargas/preseed-instalacionchmod a+w isofiles/isolinux/isolinux.binif [ -f $fichero ]then        rm -f $ficherofi      genisoimage -r -J -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o preseed-debian-10&gt;</code></pre><p>Tuve que meter la condición de que si el iso creado existía lo borrara porque al ejecutar genisoimage si el nombre ya existe provoca conflictos.</p><p>Entonces estuve probando, metiendo el usuario de la máquina con la contraseña sin encriptar, para ver el funcionamiento y que lo anterior configurado fuese por buen camino.</p><p>Estuve probando formas de encriptar la contraseña, la plantilla me recomendaba que usara  <strong>Crypt 3</strong> pero es un método muy vulnerable, así que mirando la documentación vi que podía meter un hash <strong>md5</strong>.</p><p>Entonces empecé a encriptar la contraseña, para ello utilicé <code>mkpasswd -m sha-512</code> el cual al ingresar la contraseña me la devuelve encriptada, activo la opción de <code>d-i passwd/user-password-crypted password</code> junto con la contraseña encriptada</p><p>Ya entonces, con la localización y el teclado en español, la cuenta del usuario con su contraseña encriptada decido comenzar a realizar las particiones de lvm.<br>Tuve muchísimos errores de sintaxis pero gracias al script podía probar de manera más rápida las diferentes combinaciones de particionado y ajustando la sintaxis conseguí realizarlo:</p><p><img src="/images/ASO-PRACTICA1.png" alt="Descripción de la imagen"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Compilar en debian</title>
      <link href="/2022/09/30/Compilar-en-debian/"/>
      <url>/2022/09/30/Compilar-en-debian/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/debian-11.jpg" alt="Descripción de la imagen"></p><p>Necesitamos descargar el código fuente de xorriso:<br><code>apt source xorriso</code><br>Nos pide que instalemos dpkg-dev debido a que necesita el paquete dpkg-source<br><code>apt install dpkg-dev</code><br>Con esto al descargar el código fuente de un paquete este se descomprimirá, también podemos hacerlo a través de tar:</p><p><code>tar -xvf libisoburn_1.5.2.orig.tar.gz</code></p><p><img src="/images/xorriso-1.png" alt="Descripción de la imagen"></p><p>nos metemos en la carpeta de xorriso y leemos el archivo.dsc</p><p>Como podemos ver en la imagen dentro del paquete libisoburn está las diferentes dependencias para el binario que queremos compilar.</p><p><img src="/images/xorriso-2.png" alt="Descripción de la imagen"></p><p>Como podemos observar hay dos makefile, pero estos no son más que unas plantillas que no lograremos compilar ya que solo sirven de guía.</p><p>necesitaremos las dependencias así que procuraremos hacer un <code>apt build-dep xorriso</code>.</p><p>Una vez instaladas las dependencias ejecutamos <code>./configure --prefix /usr/local/xorriso/</code>, con esto se habrá generado el makefile, y el binario generado se guardará en &#x2F;usr&#x2F;local&#x2F;xorriso</p><p><img src="/images/xorriso-3.png" alt="Descripción de la imagen"></p><p>Ahora una vez tengamos el archivo del makefile, ejecutamos un <code>make</code> en el directorio del makefile, una vez compilado realizamos un <code>make install</code></p><p><img src="/images/xorriso-4.png" alt="Descripción de la imagen"></p><p>Como podemos ver existe el binario que ejecutaremos y viene incluído el archivo de ayuda.</p><p>Otra forma después de proceder con el make a través de dpkg sería <code>dpkg-buildpackage -b</code>, se creará elarchivo .deb con el que emplearemos <code>dpkg -i archivo.deb</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
